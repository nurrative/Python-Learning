# Наследование
> ПРИНЦИП ООП, где мы можем унаследовать, переопределять и использовать все атрибуты и методы родительского класса

class A:
    def method(self):
        print("Метод в классе А")

obj_a = A()
obj_a.method()
# "Метод в классе А"

class B(A):
    pass

obj_b = B()
obj_b.method()

## Переопределение 
> когда мы создаем метод или атрибут с таким же названием, как и в родительских классах 

## Виды наследования 
* **одиночное** (когда один родитель)
* **множественное** (когда несколько родителей)
* **многоуровневое** (когда у родителя есть родитель)
* **иерархическое** (когда у каждого есть один родитель, но у родителя может
быть много детей)
* **гибридное** (совмещение разных видов наследования)

## Проблемы множественного наследования
1. Проблема ромба (решенная с помощью MRO(c версии 2.3))
> MRO - method resolution order (простраивает порядок для поиска атрибута)
```py
class A:
    pass
class B:
    pass
class C(A,B):
    pass

#до mro
[C,A,object,C,B,object]

#после mro
[C,A,B,object]
```

2. Проблема перекрестного наследования(не решенная, возникает когда не возможно построить приоритет родителей)
